/*
 * Copyright (c) 2012, Mattias Holm <lorrden(at)openorbit.org>.
 * All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <celmek/celmek.h>

typedef struct {
  double a, b, c;
} vsop87_term_t;

typedef struct {
  size_t size_x[6];
  size_t size_y[6];
  size_t size_z[6];
  vsop87_term_t *terms_x[6];
  vsop87_term_t *terms_y[6];
  vsop87_term_t *terms_z[6];
} vsop87_body_t;

// Include parameters, these are generated by the vsop termextract script
#include "vsop87-sun.h"
#include "vsop87-mercury.h"
#include "vsop87-venus.h"
#include "vsop87-earth.h"
#include "vsop87-mars.h"
#include "vsop87-jupiter.h"
#include "vsop87-saturn.h"
#include "vsop87-uranus.h"
#include "vsop87-neptune.h"


cm_state_vectors_t vsop87_pos_at_jd(vsop87_body_t *body, double jd);
void vsop87_init_model(cm_orbital_model_t *model);
void vsop87_step_model(cm_orbital_model_t *model, cm_world_t *state);
void vsop87_step_object(cm_orbit_t *obj, cm_world_t *state);
void vsop87_transform(cm_orbit_t *obj, cm_world_t *state);

void vsop87_init(void);

vsop87_body_t* vsop87_get_body(cm_body_id_t bodyid);


cm_body_id_t
vsop87_body_id_from_string(const char *s)
{
  if (!strcmp(s, "sun")) return CM_SUN;
  else if (!strcmp(s, "mercury")) return CM_MERCURY;
  else if (!strcmp(s, "venus")) return CM_VENUS;
  else if (!strcmp(s, "earth")) return CM_EARTH;
  else if (!strcmp(s, "mars")) return CM_MARS;
  else if (!strcmp(s, "jupiter")) return CM_JUPITER;
  else if (!strcmp(s, "saturn")) return CM_SATURN;
  else if (!strcmp(s, "uranus")) return CM_URANUS;
  else if (!strcmp(s, "neptune")) return CM_NEPTUNE;
  return -1;
}

static vsop87_body_t *bodies[] = {
  &sun, &mercury, &venus, &earth, &mars, &jupiter, &saturn, &uranus, &neptune
};

vsop87_body_t*
vsop87_get_body(cm_body_id_t bodyid)
{
  return bodies[bodyid];
}

// Derivative of A cos (B + C t) is -A C sin(B + Ct)
// So: A cos (B + C t) * t    : A cos (B + C t) - C t sin(B + C t)
//     A cos (B + C t) * t * t: A t (2 cos (B + C t) - C t sin (B + C t))
//     A cos (B + C t) * t * t * t: A t2 (3 cos (B+Ct) - Ct sin B+Ct)
cm_state_vectors_t
vsop87_pos_at_jd(vsop87_body_t *body, double jd) {
  double t = (jd - 2451545.0) / 365250.0;

  double x[6], y[6], z[6];
  double vx[6], vy[6], vz[6];
  memset(x, 0, sizeof(x));
  memset(y, 0, sizeof(y));
  memset(z, 0, sizeof(z));
  memset(vx, 0, sizeof(x));
  memset(vy, 0, sizeof(y));
  memset(vz, 0, sizeof(z));

  for (int i = 0 ; i < 6 ; i ++) {
    for (int j = 0 ; j < body->size_x[i] ; j ++) {        
      vsop87_term_t *coefs = &body->terms_x[i][j];
      double term = coefs->a * cos(coefs->b + coefs->c * t);
      x[i] += term;
      double vterm = coefs->a * coefs->c * sin(coefs->b + coefs->c * t);
      vx[i] += vterm;
    }
  }

  for (int i = 0 ; i < 6; i ++) {
    for (int j = 0 ; j < body->size_y[i] ; j ++) {        
      vsop87_term_t *coefs = &body->terms_y[i][j];
      double term = coefs->a * cos(coefs->b + coefs->c * t);
      y[i] += term;
      double vterm = coefs->a * coefs->c * sin(coefs->b + coefs->c * t);
      vy[i] += vterm;
    }
  }

  for (int i = 0 ; i < 6 ; i ++) {
    for (int j = 0 ; j < body->size_z[i] ; j ++) {        
      vsop87_term_t *coefs = &body->terms_z[i][j];
      double term = coefs->a * cos(coefs->b + coefs->c * t);
      z[i] += term;
      double vterm = coefs->a * coefs->c * sin(coefs->b + coefs->c * t);
      vz[i] += vterm;
    }
  }

  cm_state_vectors_t res;

  double T[6];
  T[0] = 1.0;
  for (int i = 1 ; i < 6 ; i++) {
    T[i] = T[i-1] * t;
  }

  res.p.x = x[0]
          + x[1] * T[1]
          + x[2] * T[2]
          + x[3] * T[3]
          + x[4] * T[4]
          + x[5] * T[5];
  res.p.y = y[0]
          + y[1] * T[1]
          + y[2] * T[2]
          + y[3] * T[3]
          + y[4] * T[4]
          + y[5] * T[5];
  res.p.z = z[0]
          + z[1] * T[1]
          + z[2] * T[2]
          + z[3] * T[3]
          + z[4] * T[4]
          + z[5] * T[5];


// ddt A cos (B + C t)                                    - A C   sin (B + C t)
// So: A cos (B + C t) * t        :    (1 A cos (B + C t) - A C t sin (B + C t))
//     A cos (B + C t) * t * t    : t  (2 A cos (B + C t) - A C t sin (B + C t))
//     A cos (B + C t) * t * t * t: t2 (3 A cos (B + C t) - A C t sin (B + C t))

  res.v.x =                    -        vx[0]
          + (1.0 *        x[1] - T[1] * vx[1])
          + (2.0 * T[1] * x[2] - T[2] * vx[2])
          + (3.0 * T[2] * x[3] - T[3] * vx[3])
          + (4.0 * T[3] * x[4] - T[4] * vx[4])
          + (5.0 * T[4] * x[5] - T[5] * vx[5]);
  res.v.y =                    -        vy[0]
          + (1.0        * x[1] - T[1] * vy[1])
          + (2.0 * T[1] * x[2] - T[2] * vy[2])
          + (3.0 * T[2] * x[3] - T[3] * vy[3])
          + (4.0 * T[3] * x[4] - T[4] * vy[4])
          + (5.0 * T[4] * x[5] - T[5] * vy[5]);
  res.v.z =                    -        vz[0]
          + (1.0 *        z[1] - T[1] * vz[1])
          + (2.0 * T[1] * z[2] - T[2] * vz[2])
          + (3.0 * T[2] * z[3] - T[3] * vz[3])
          + (4.0 * T[3] * z[4] - T[4] * vz[4])
          + (5.0 * T[4] * z[5] - T[5] * vz[5]);

  res.v.x /= 365250.0;
  res.v.y /= 365250.0;
  res.v.z /= 365250.0;
  return res;
}

cm_state_vectors_t
cm_vsop87(cm_body_id_t body, double jde)
{
  vsop87_body_t *b = vsop87_get_body(body);
  return vsop87_pos_at_jd(b, jde);
}


void
vsop87_step_model(cm_orbital_model_t *model, cm_world_t *state)
{
  
}

void
vsop87_step_object(cm_orbit_t *obj, cm_world_t *state)
{
  vsop87_body_t *body = obj->omod_data;

  cm_state_vectors_t pos = vsop87_pos_at_jd(body, state->jde);

  // Transform to FK5 / ICRF, the matrix given in vsop87.doc (it is not
  // actually, ICRF, but FK5 is close enough).
  double3x3 R = {
    { 1.000000000000, 0.000000440360, -0.000000190919},
    {-0.000000479966, 0.917482137087, -0.397776982902},
    { 0.000000000000, 0.397776982902,  0.917482137087}};

  pos.p = md3_v_mul(R, pos.p);
  pos.v = md3_v_mul(R, pos.v);

  obj->p.x = pos.p.x * CM_AU_IN_M;
  obj->p.y = pos.p.y * CM_AU_IN_M;
  obj->p.z = pos.p.z * CM_AU_IN_M;

  obj->v.x = pos.v.x * CM_AU_IN_M / CM_SEC_PER_DAY;
  obj->v.y = pos.v.y * CM_AU_IN_M / CM_SEC_PER_DAY;
  obj->v.z = pos.v.z * CM_AU_IN_M / CM_SEC_PER_DAY;
}

void
vsop87_transform(cm_orbit_t *obj, cm_world_t *state)
{
  
}

void
vsop87_init_object(cm_orbit_t *obj)
{
  cm_body_id_t b_id = vsop87_body_id_from_string(obj->name);
  if (b_id == -1) return; // TODO: generate error
  
  obj->omod_data = bodies[b_id];
}

static cm_orbital_model_t vsop87_model = {
  .name = "vsop87",
  .init_object = vsop87_init_object,
  .step_model = vsop87_step_model,
  .step_object = vsop87_step_object,
  .transform = vsop87_transform,
};

void
vsop87_init(void)
{
  cm_register_orbital_model(&vsop87_model);
}
